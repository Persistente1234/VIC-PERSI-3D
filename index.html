<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Project</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=New+Rocker&display=swap');
    body{
      overflow: hidden;
      margin: 0;
      background-color: gray;
    }
    
    #writing{
      text-align: center;
      color: red;
      font-family: "New Rocker", system-ui;
      font-weight: 400;
      font-style: normal;
      font-size: 4vh;
      min-width: 50vh;
      max-width: 50vh;
      position: absolute;
      left: 50%;
      bottom: 0vh;
      transform: translate(-50%, -50%);
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="writing">Creador, VIC_PERSI.<br/>Programador y Dise√±ador Grafico.</div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.177.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.177.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { SimplexNoise } from "three/addons/math/SimplexNoise.js";

    // Voronoi and Noise shaders are embedded here
    let voronoi = `
    const mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);
    const vec2 mys = vec2(1e4, 1e6);

    vec2 rhash(vec2 uv) {
      uv *= myt;
      uv *= mys;
      return fract(fract(uv / mys) * uv);
    }

    vec3 hash(vec3 p) {
      return fract(
          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),
                   dot(p, vec3(113.0, 1.0, 57.0)))) *
          43758.5453);
    }

    vec3 voronoi3d(const in vec3 x) {
      vec3 p = floor(x);
      vec3 f = fract(x);

      float id = 0.0;
      vec2 res = vec2(100.0);
      for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
          for (int i = -1; i <= 1; i++) {
            vec3 b = vec3(float(i), float(j), float(k));
            vec3 r = vec3(b) - f + hash(p + b);
            float d = dot(r, r);

            float cond = max(sign(res.x - d), 0.0);
            float nCond = 1.0 - cond;

            float cond2 = nCond * max(sign(res.y - d), 0.0);
            float nCond2 = 1.0 - cond2;

            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);
            res = vec2(d, res.x) * cond + res * nCond;

            res.y = cond2 * d + nCond2 * res.y;
          }
        }
      }

      return vec3(sqrt(res), id);
    }
    `;
      
    let noise = `
    //	Simplex 4D Noise 
    //	by Ian McEwan, Ashima Arts
    //
    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
    float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
    float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}

    vec4 grad4(float j, vec4 ip){
      const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
      vec4 p,s;

      p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
      p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
      s = vec4(lessThan(p, vec4(0.0)));
      p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

      return p;
    }

    float snoise(vec4 v){
      const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4
                            0.309016994374947451); // (sqrt(5) - 1)/4   F4
    // First corner
      vec4 i  = floor(v + dot(v, C.yyyy) );
      vec4 x0 = v -   i + dot(i, C.xxxx);

    // Other corners

    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
      vec4 i0;

      vec3 isX = step( x0.yzw, x0.xxx );
      vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
      i0.x = isX.x + isX.y + isX.z;
      i0.yzw = 1.0 - isX;

    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
      i0.y += isYZ.x + isYZ.y;
      i0.zw += 1.0 - isYZ.xy;

      i0.z += isYZ.z;
      i0.w += 1.0 - isYZ.z;

      // i0 now contains the unique values 0,1,2,3 in each channel
      vec4 i3 = clamp( i0, 0.0, 1.0 );
      vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
      vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

      //  x0 = x0 - 0.0 + 0.0 * C 
      vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
      vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
      vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
      vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

    // Permutations
      i = mod(i, 289.0); 
      float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
      vec4 j1 = permute( permute( permute( permute (
                 i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
               + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
               + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
               + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
    // Gradients
    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.

      vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

      vec4 p0 = grad4(j0,   ip);
      vec4 p1 = grad4(j1.x, ip);
      vec4 p2 = grad4(j1.y, ip);
      vec4 p3 = grad4(j1.z, ip);
      vec4 p4 = grad4(j1.w, ip);

    // Normalise gradients
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      p4 *= taylorInvSqrt(dot(p4,p4));

    // Mix contributions from the five corners
      vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
      vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
      m0 = m0 * m0;
      m1 = m1 * m1;
      return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                   + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;

    }
    `;

    console.clear();

    let { smoothstep, clamp, degToRad } = THREE.MathUtils;

    let simplex = new SimplexNoise();

    // load fonts
    await (async function () {
      async function loadFont(fontface) {
        await fontface.load();
        document.fonts.add(fontface);
      }
      let fonts = [
        new FontFace(
          "Stick",
          "url(https://fonts.gstatic.com/s/stick/v19/Qw3TZQpMCyTtJRvYtvQ.woff2) format('woff2')"
        )
      ];
      for (let font in fonts) {
        await loadFont(fonts[font]);
      }
    })();

    const loader = new GLTFLoader();
    let head = (
      await loader.loadAsync(
        "https://threejs.org/examples/models/gltf/LeePerrySmith/LeePerrySmith.glb"
      )
    ).scene.children[0];

    class Model extends THREE.Mesh {
      constructor(model) {
        super();
        this.geometry = model.geometry.toNonIndexed();
        this.material = new THREE.MeshLambertMaterial({
          color: "red",
          onBeforeCompile: (shader) => {
            shader.uniforms.time = gu.time;
            shader.vertexShader = `
              varying vec3 vPos;
              ${shader.vertexShader}
            `.replace(
              `#include <begin_vertex>`,
              `#include <begin_vertex>
                vPos = position;
              `
            );
            //console.log(shader.vertexShader);

            shader.fragmentShader = `
              uniform float time;
              varying vec3 vPos;
              
              ${voronoi}
              
              ${shader.fragmentShader}
            `.replace(
              `#include <color_fragment>`,
              `#include <color_fragment>
              
              float t = time * 0.5;
              vec3 pos = vPos;
              pos.z += t;
              
              float vn = voronoi3d(pos * 3.).z + 800. - t * 339.;
              float vnSign = sign(vn);
              diffuseColor.rgb *= clamp(vec3(pow(abs(vn) * 0.0005, 4.) * vnSign), 0., 1.);
              `
            );
            //console.log(shader.fragmentShader);
          }
        });
        
        this.receiveShadow = true;
        this.castShadow = true;
        
        // pins
        let pinR = 0.015;
        let pinL = 0.5;
        let gPin = new THREE.LatheGeometry(
          [
            [pinR, 0],
            [pinR, pinL],
            [pinR * 2, pinL],
            [pinR * 3, pinL + pinR * 0.5],
            [pinR * 2, pinL + pinR],
            [0, pinL + pinR]
          ].map(p => {return new THREE.Vector2(...p)})
          ,7
        ).rotateX(Math.PI * 0.5);
        
        let gPins = [];
        let v3 = new THREE.Vector3();
        let v2 = new THREE.Vector2();
        let ray = new THREE.Raycaster();
        let ori = new THREE.Vector3();
        let dir = new THREE.Vector3();
        let axi = new THREE.Vector3(1, 0, 0);
        let intersections;
        let constrains = [
          {x1: -0.5, y1: 0.3, x2: 0.3, y2: 0.7}, // mouth
          {x1: -1, y1: 1.25, x2: -0.25, y2: 2}, // left eye
          {x1: 0.1, y1: 1.25, x2: 0.9, y2: 2}, // right eye
        ].map(b => {
          // helpers
          let box3 = new THREE.Box3(
            new THREE.Vector3(b.x1, b.y1, 0), 
            new THREE.Vector3(b.x2, b.y2, 3)
          );
          //let boxHelper = new THREE.Box3Helper(box3);
          //this.add(boxHelper);
          
          return box3;
        });
        
        let setRow = (shiftX, shiftY, angleStart, angleEnd, amount, skipping) => {
          let aStep = (angleEnd - angleStart) / amount;
          for(let i = 0; i <= amount; i++){
            
            let a = aStep * i + angleStart;
            
            ori.set(shiftX, 0, -5).applyAxisAngle(axi, a);
            dir.copy(ori).setX(0).normalize().negate();
            ori.y += shiftY;
            ray.set(ori, dir);
            
            intersections = ray.intersectObject(this, false);
            
            if (intersections.length > 0){
              let p = intersections[0].point;
              let n = intersections[0].normal;
              let constraned = false;
              if(skipping){
                console.log("skipping!")
                for(let j = 0; j < constrains.length; j++){
                  if(constrains[j].containsPoint(p)){
                    constraned = true;
                    break;
                  }
                }
              }  
              if (constraned == true) continue;
              
              let gp = gPin.clone();
              gp.lookAt(n).translate(...p);
              gPins.push(gp);
            }
          }
          
        }
        
        setRow(-0.1, 0.5, degToRad(30), degToRad(200), 14, false);
        
        setRow(-0.5, 0.5,  degToRad(30), degToRad(200), 14, true);
        setRow(0.3, 0.5,  degToRad(30), degToRad(200), 14, true);
        
        setRow(-0.8, 0.5,  degToRad(32), degToRad(200), 14, true);
        setRow(0.7, 0.5,  degToRad(32), degToRad(200), 14, true);
        
        setRow(-1.2, 0.5,  degToRad(40), degToRad(180), 14, false);
        setRow(1.05, 0.5,  degToRad(40), degToRad(180), 14, false);
        
        setRow(-1.45, 1.0, degToRad(40), degToRad(180), 12, false);
        setRow(1.275, 1.0, degToRad(40), degToRad(180), 12, false);
        
        setRow(-1.55, 1.5, degToRad(30), degToRad(120), 5, false);
        setRow(1.35, 1.5, degToRad(30), degToRad(120), 5, false);
        
        
        console.log(gPins);
        
        let mergedPins = mergeGeometries(gPins);
        
        let mPin = new THREE.MeshLambertMaterial({
          color: "red"
        });
        
        let pin = new THREE.Mesh(mergedPins, mPin);
        pin.castShadow = true;
        pin.receiveShadow = true;
        this.add(pin)
      }
    }

    class Nimbus extends THREE.Mesh {
      constructor() {
        super();
        let canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1024;
        let unit = canvas.height * 0.01;
        this.u = val => val * unit;
        this.ctx = canvas.getContext("2d");
        let canvasTexture = new THREE.CanvasTexture(canvas);
        canvasTexture.premultiplyAlpha = true;
        canvasTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        this.geometry = new THREE.PlaneGeometry(5, 5);
        this.material = new THREE.MeshBasicMaterial({
          color: "red",
          side: THREE.DoubleSide,
          transparent: true,
          map: canvasTexture
        });
        this.position.y = 4.7;
      }
      
      update(t){
        let r = 48;
        
        let ctx = this.ctx;
        let u = this.u;
        
        ctx.clearRect(0, 0, u(100), u(100));
        
        ctx.save();
        
          ctx.translate(u(50), u(50));
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          //circle
          ctx.lineWidth = u(2);
          ctx.strokeStyle = `rgba(255, 255, 255, ${Math.sin(t * Math.PI * 2) * 0.25 + 0.75})`;
          ctx.beginPath()
          ctx.arc(0, 0, u(r), 0, Math.PI * 2);
          ctx.stroke();
          
          let a = Math.PI * 2 / 5;
          let startA = Math.PI * 0.5;
          // glass
          let rInner = r * (30 / 75);
          let grd = ctx.createLinearGradient(0, 0, 0, -u(40));
          grd.addColorStop(0.55, "rgba(255, 255, 255, 0.50)");
          grd.addColorStop(0.65, "rgba(255, 255, 255, 0.95)");
          grd.addColorStop(0.75, "rgba(255, 255, 255, 0.95)");
          grd.addColorStop(0.85, "rgba(255, 255, 255, 0.60)");
          grd.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.moveTo(
            Math.cos(a * 2 + startA) * u(r),
            Math.sin(a * 2 + startA) * u(r)
          );
          ctx.lineTo(
            Math.cos(a * 3 + startA) * u(r),
            Math.sin(a * 3 + startA) * u(r)
          );
          ctx.lineTo(
            Math.cos(startA - a * 0.5) * u(rInner),
            Math.sin(startA - a * 0.5) * u(rInner)
          );
          ctx.lineTo(
            Math.cos(startA + a * 0.5) * u(rInner),
            Math.sin(startA + a * 0.5) * u(rInner)
          )
          ctx.fill();
        
          // text
          ctx.save();
            ctx.font = `${u(20)}px Stick`;
            ctx.fillStyle = "rgba(255, 255, 255, 1)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = `rgba(255, 255, 255, ${Math.sin(t * 0.37 + Math.cos(t * 2 + Math.sin(t * 5) * 0.1) * 0.5) * 0.5 + 0.5})`;
            ctx.shadowBlur = u(3);
            ctx.fillText("VICPERSI", 0, -u(5));
          ctx.restore();
          
          // pentacle
          ctx.lineWidth = u(1.5);
          ctx.strokeStyle = `rgba(255, 255, 255, ${Math.sin(t * Math.PI) * 0.25 + 0.75})`;
          ctx.beginPath();
            for(let i = 0; i <= 5; i++){
              ctx[i == 0 ? "moveTo" : "lineTo"](
                Math.cos(a * i * 2 + startA) * u(r),
                Math.sin(a * i * 2 + startA) * u(r)
              )
            }
          ctx.stroke();

        ctx.restore();
        
        this.material.map.needsUpdate = true;
      }
    }

    class Background extends THREE.Mesh{
      constructor(){
        super();
        
        this.geometry = new THREE.SphereGeometry(500);
        this.material = new THREE.MeshBasicMaterial({
          color: "red",
          side: THREE.BackSide,
          onBeforeCompile: shader => {
            shader.uniforms.time = gu.time;
            shader.vertexShader = `
              varying vec3 vPos;
              ${shader.vertexShader}
            `.replace(
              `#include <begin_vertex>`,
              `#include <begin_vertex>
                vPos = position;
              `
            );
            
            shader.fragmentShader = `
              #define ss(a, b, c) smoothstep(a, b, c)
              uniform float time;
              varying vec3 vPos;
              ${noise}
              ${shader.fragmentShader}
            `.replace(
              `#include <color_fragment>`,
              `#include <color_fragment>
              
                float t = time * 0.1;
                
                vec3 col1 = vec3(0);
                vec3 col2 = col1 + mix(diffuse, diffuse * 0.75, ss(-25., 125., vPos.y)) * 0.2;
                
                vec3 pos = vPos;
                pos.xz = normalize(vPos.xz) * 15.;
                pos.y -= time * 25.;
                pos.y *= 0.01;
                
                float n = snoise(vec4(pos, t)) * 0.5 + 0.5;
                float f = n * (ss(-150., -50., vPos.y) - ss(-25., 300., vPos.y));
                f *= f;
                
                float appearance = 1.;
                
                diffuseColor.rgb = mix(col1, col2, f * appearance);
              
              `
            );
          }
        });
        this.material.defines = {"USE_UV" : ""};
      }
    }

    let gu = {
      time: {
        value: 0
      },
      aspect: {
        value: innerWidth / innerHeight
      }
    };
    let dpr = Math.min(devicePixelRatio, 1);
    let scene = new THREE.Scene();
    //scene.background = new THREE.Color(0x444444);
    let camera = new THREE.PerspectiveCamera(30, innerWidth / innerHeight, 1, 1000);
    camera.position.set(0, 0, 1).setLength(20);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth * dpr, innerHeight * dpr);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    window.addEventListener("resize", (event) => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth * dpr, innerHeight * dpr);
      gu.aspect.value = camera.aspect;
    });

    let camShift = new THREE.Vector3(0, 2, 0);
    camera.position.add(camShift);
    let controls = new OrbitControls(camera, renderer.domElement);
    controls.target.add(camShift);
    controls.enableDamping = true;

    let light = new THREE.DirectionalLight(0xffffff, Math.PI * 1.75);
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    light.position.set(0.5, 1, 1).multiplyScalar(10);
    light.castShadow = true;
    scene.add(light, new THREE.AmbientLight(0xffffff, Math.PI * 0.25));

    // stuff
    let background = new Background();
    scene.add(background);

    let model = new Model(head);
    scene.add(model);

    let nimbus = new Nimbus();
    scene.add(nimbus);
    ////////

    let clock = new THREE.Clock();
    let t = 0;

    renderer.setAnimationLoop(() => {
      let dt = clock.getDelta();
      t += dt;
      gu.time.value = t;
      light.position.x = Math.sin(t * 0.1) * 5;
      controls.update();
      nimbus.update(t);
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
  
  </head>
<body>
    <audio id="bg-music" loop autoplay>
        <source src="marylin.mp3" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const body = document.body;
            const audio = document.getElementById('bg-music');
            
            // Configurar audio
            audio.volume = 0.4;
            audio.play().catch(e => console.log("La reproducci√≥n autom√°tica no est√° permitida"));

 document.addEventListener('click', function() {
                audio.play().catch(e => console.log("Audio no pudo reproducirse"));
            }, { once: true });
        });
    </script>
</body>
</html>
